\documentclass{article}
%% Выставим минимальные поля, согласно новому ГОСТу:
\usepackage[letterpaper, top = 2cm, bottom = 2cm, left = 2cm, right = 1cm]{geometry}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
%% Импортируем русский язык:
\usepackage[russian]{babel}
\usepackage{setspace}
\usepackage[pdf]{graphviz}
\usepackage{braket}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{xcolor}
%% Заготовки для отображения кода
\definecolor{codeblue}{rgb}{0.25,0.5,0.5}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}
\definecolor{keycolor}{rgb}{0,0.5,0}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour}, commentstyle=\color{codeblue},
  keywordstyle=\color{keycolor},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

%% Заголовок, автор и дата:
\title{Теоретические модели вычислений \\ ДЗ №3: Машины Тьюринга и квантовые вычисления}
\author{А-13б-19 Сергей Тимченко}
\date{17 мая 2022}


\begin{document}

\maketitle

%% Задание №2.1 
\section{Машины Тьюринга}
Все решения представлены в папке \href{https://github.com/NRU-MPEI-IMAI/tm-and-qc-s3tout/tree/main/TMV3}{TMV3}. 
\subsection{Операции с числами}

Реализуйте машины Тьюринга, которые позволяют выполнять следующие операции:
\begin{enumerate}
    %% 2.1_1
    \item Сложение двух унарных чисел (1 балл) \\ \\
    \textbf{Решение представлено в файле \href{https://github.com/NRU-MPEI-IMAI/tm-and-qc-s3tout/blob/main/TMV3/2.1_1.yaml}{2.1\_1.yaml}.} \\
    В моей реализации на вход подается два унарных числа, разделенных знаком +. Результатом является унарное число, являющееся суммой двух данным. 
    К примеру: 
    \begin{center}
        \begin{tabular}{c|c}
        Вход    & Результат     \\ \hline
        11+111  & 11111         \\
        1+1     & 11            \\
        +1      & 1             \\
        1+      & 1
    \end{tabular}
    \end{center}
    Можно заметить, что в данном случае сделал также реализацию, если отсутствует (равно 0) 1 или 2 число. Алгоритм работы прост: находим единицу в правом слагаемом, заменяем ее на 0 и переносим влево. В конце необходимо "почистить" строку (убрать + и 0). Учитываю уникальный случай, если отсутствует первое число. 
    
    %% 2.1_2
    \item Умножение унарных чисел (1 балл) \\ \\
    \textbf{Решение представлено в файле \href{https://github.com/NRU-MPEI-IMAI/tm-and-qc-s3tout/blob/main/TMV3/2.1_2.yaml}{2.1\_2.yaml}.} \\
    В моей реализации на вход подается два унарных числа, разделенных знаком *. Результатом является унарное число, являющееся произведение двух данным. 
    К примеру: 
    \begin{center}
        \begin{tabular}{c|c}
        Вход    & Результат     \\ \hline
        11*111  & 111111        \\
        1*1     & 1             \\
        *1      &               \\
        1*      &  
    \end{tabular}
    \end{center}
    Можно заметить, что в данном случае сделал также реализацию, если отсутствует (равно 0) 1 или 2 число. В реализации использую два дополнительных знака. Алгоритм работы:
    \begin{itemize}
         \item Находим *, путем прохода в правую сторону.
        \item Находим первую 1 правого множителя, заменяем ее на 0, уходим влево, пока не найдем первую 1 левого множителя.
        \item Заменяем найденную 1 на 0 и уходим в левый край, ставим дополнительный знак x.
        \item Снова находим * и повторяем копирование остальных единиц (если есть) левого множителя (ставим дополнительный знак x слева, заменяем 1 на 0). Так производим, пока не встретится x при поиске 1. 
        \item Повторяем предыдущие три шага, пока не уйдем за границы второго множителя. 
        \item Производим "чистку" и замену: удаляем 0 и *, вместо x пишем 1. 
    \end{itemize}
    находим единицу в правом числе, заменяем ее на 0 и переносим влево. В конце необходимо "почистить" строку (убрать + и 0). Учитываю уникальный случай, если отсутствует первое число. 
\end{enumerate}

%% Задание №2.2
\subsection{Операции с языками и символами}

Реализуйте машины Тьюринга, которые позволяют выполнять следующие операции:
\begin{enumerate}
    %% 2.2_1
    \item Принадлежность к языку $L = \{ 0^n1^n2^n \}, n \ge 0$ (0.5 балла) \\ \\
    \textbf{Решение представлено в файле \href{https://github.com/NRU-MPEI-IMAI/tm-and-qc-s3tout/blob/main/TMV3/2.2_1.yaml}{2.2\_1.yaml}.} \\
    На вход подается строка из 0, 1, 2. Результат работы 1 или 0, если слово принадлежит или не принадлежит языку $L$ соответственно. \\
    Алгоритм:
    \begin{itemize}
        \item Нулевой шаг: учитываем пустое слово. В данном случае сразу даем ответ 1. 
        \item На данном этапе мы точно имеем не пустое слово. Заменяем все первые вхождения 0, 1 и 2 на дополнительный знак x. Если не встречается хотя бы одного знака, то очищаем строку, даем ответ 0. 
        \item После замены находим первое вхождение 0 и повторяем предыдущий шаг, пока не закончатся 0. 
        \item Если в строке остаются 1 или 2, очищаем и выводим ответ 0. В ином случае очищаем строку и выводим ответ 1. 
    \end{itemize}
    Вкратце представлю работу алгоритма: 
    \begin{center}
    \begin{tabular}{c|c}
        Условный шаг    & Значение в строке     \\ \hline
        1   & 001122        \\
        2   & x0x1x2        \\
        3   & xxxxxx        \\
        4   & 1
    \end{tabular} 
        \begin{tabular}{c|c}
        Условный шаг    & Значение в строке     \\ \hline
        1   & 0011122       \\
        2   & x0x11x2        \\
        3   & xxx1xxx        \\
        4   & 0
    \end{tabular}
    \end{center}
    Примечание: не стал расписывать конкретную реализацию шага 2. Постарался оптимизировать работу машины. 
    
    %% 2.2_2
    \item Проверка соблюдения правильности скобок в строке (минимум 3 вида скобок) (0.5 балла) \\ \\
    \textbf{Решение представлено в файле \href{https://github.com/NRU-MPEI-IMAI/tm-and-qc-s3tout/blob/main/TMV3/2.2_2.yaml}{2.2\_2.yaml}.} \\
    На вход подается строка из (, ), \{, \}, [, ]. Результат работы 1 или 0, если слово является правильной скобочной последовательностью и нет соответственно.
    Алгоритм решения:
    \begin{itemize}
        \item Пустое слово - правильная скобочная последовательность без скобок. Даем ответ 1. 
        \item На данном этапе мы точно имеем не пустое слово. Проходим вправо и игнорируем любые открывающиеся скобки. Делаем до тех пор, пока не встретим первую любую закрывающуюся скобку, заменяем ее на дополнительный знак x, уходим влево.
        \item Так это первая закрывающаяся скобки, то мы в любом случае получим на этом этапе открывающуюся скобку. Если она соответствует найденной закрывающейся, то заменяем на доп. знак x и повторяем предыдущий шаг. Если не соответствует, то очищаем строку выводим ответ 0. 
        \item При повторении предыдущего шага пропускаем дополнительный знак. Делаем до тех пор, пока не закончатся закрывающиеся скобки.
        \item Если в строке остались только дополнительные знаки, то очищаем строку и выводим ответ 1, в ином случае очищаем и выводим ответ 0. 
    \end{itemize}
    Вкратце представлю работу алгоритма: 
    \begin{center}
    \begin{tabular}{c|c}
        Условный шаг    & Значение в строке     \\ \hline
        1   & \{\{\}([])\}      \\
        2   & \{\{x([])\}       \\
        3   & \{xx([])\}        \\
        4   & \{xx([x)\}        \\
        5   & \{xx(xx)\}        \\
        6   & \{xx(xxx\}        \\
        7   & \{xxxxxx\}        \\
        8   & \{xxxxxx         \\
        9   & xxxxxxx          \\
        10  & 1                 \\
    \end{tabular} 
    \begin{tabular}{c|c}
        Условный шаг    & Значение в строке     \\ \hline
        1   & \{\{\}([\}])\}      \\
        2   & \{\{x([\}])\}       \\
        3   & \{xx([\}])\}        \\
        4   & \{xx([x])\}        \\
        5   & 0
    \end{tabular}
    \end{center}
    Примечание: опять же, в данном случае не досканально описал алгоритм, а только тезисно.
    
    %% 2.2_3
    \item Поиск минимального по длине слова в строке (слова состоят из символов 1 и 0 и разделены пробелом) (1 балл) \\ \\ 
    \textbf{Решение представлено в файле \href{https://github.com/NRU-MPEI-IMAI/tm-and-qc-s3tout/blob/main/TMV3/2.1_2.yaml}{2.2\_3.yaml}.} \\
    На вход строка из слов, состоящих из 1 и 0, разделенных пробелом. Результат работы - самое короткое слово в строке. 
    Алгоритм решения построен на создании унарного числа, которое соответствует длине минимального слова в строке. 
    \begin{itemize}
        \item Если введена пустая строка это и является ответом. 
        \item Берем первое слово за основу минимального. Создаем для него слева унарное число, соответствующее длине этого слова. Заменяем 1 этого слова на доп. знак x, 0 - на y. Также дополнительно использую знак p слева от длины слова для стопа. 
        \item Если в строке больше нет слов, то удаляем длину и заменяем x на 1, y на 0. Иначе на следующий шаг
        \item В строке остались слова. Сопоставляем каждый символ нового слова с длиной минимального, заменяем 1 на z, 0 на w (для этого заменяется в длине 1 на l). Если выходит так, что достигается знак p, то слово является длиннее минимального. Оно очищается, длина восстанавливается (с l на 1). Если слово по длине такое же или меньше, то это означает, что мы достигнем пробела после него. Получается это за счет того, что мы смотрим по одному символу из слова и постоянно "бегаем" влево-вправо от слова к длине. В данном случае мы удаляем минимальное слово и его длину, заменяем z на x, w на y, а также снова формируем длину нового минимального слова. 
        \item Если в строке больше нет слов, то очищаем длину и заменяем x на 1, y на 0. 
    \end{itemize}
    Примечание: аналогично описал тезисно весь алгоритм. Постарался оптимизировать процесс. Например, если нашел новое минимальное слово и больше после него нет слов, то сразу же удалял старое минимальное и его длину, z заменял на 1, а w на 0. 
    Вкратце представлю работу алгоритма: 
    \begin{center}
    \begin{tabular}{c|c}
        Условный шаг    & Значение в строке     \\ \hline
        1   & 101 11 101        \\
        2   & p111 xyx 11 101   \\
        3   & p1ll xyx zz 101   \\
        4   & p11 xx 101        \\
        5   & pll xx zw1        \\
        6   & p11 xx            \\
        7   & 11                \\
    \end{tabular} 
    \begin{tabular}{c|c}
        Условный шаг    & Значение в строке     \\ \hline
        1   & 101 11 10         \\
        2   & p111 xyx 11 10    \\
        3   & p1ll xyx zz 10    \\
        4   & p11 xx 10         \\
        5   & pll xx zw         \\
        6   & zw                \\
        7   & 11                \\
    \end{tabular} 
    \end{center}
    Во втором примере как раз показал работу двух пунктов: встречено слово минимальной длины и заменено и оно же является последним. 
\end{enumerate}
\newpage

\section{Квантовые вычисления}
В данном задании представил решения на $Python$ с использованием пакета $qiskit$. В данном отчете представляю кусочки кода основных процедур и функций, а для наглядности предлагаю перейти в ноутбук: \href{https://github.com/NRU-MPEI-IMAI/tm-and-qc-s3tout/blob/main/Quantum_task.ipynb}{Quantum\_task.ipynb}.
%% Задание 3.1
\subsection{Генерация суперпозиций 1 (1 балл)}

Дано $N$ кубитов ($1 \le N \le 8$) в нулевом состоянии $\Ket{0\dots0}$. Также дана некоторая последовательность битов, которое задаёт ненулевое базисное состояние размера $N$. Задача получить суперпозицию нулевого состояния и заданного.

$$\Ket{S} = \frac{1}{\sqrt2}(\Ket{0\dots0} +\Ket{\psi})$$

То есть требуется реализовать операцию, которая принимает на вход:

\begin{enumerate}
    \item Массив кубитов $q_s$
    \item Массив битов $bits$ описывающих некоторое состояние $\Ket{\psi}$. Это массив имеет тот же самый размер, что и $q_s$. Первый элемент этого массива равен $1$.
\end{enumerate}
Код для основной процедуры:
\begin{lstlisting}[language=Python]
def Solve_First(q, psi):
    global circuit
    circuit.h(0)                    # Hadamar for first qubit
    circuit.barrier()
    for i in range (1, len(psi)):
        if psi[i]:                  # for each 1 qubit in psi making CNOT
            circuit.cx(q[0], q[i])
\end{lstlisting}


\subsection{Различение состояний 1 (1 балл)}

Дано $N$ кубитов ($1 \le N \le 8$), которые могут быть в одном из двух состояний:

$$\Ket{GHZ} = \frac{1}{\sqrt2}(\Ket{0\dots0} +\Ket{1\dots1})$$
$$\Ket{W} = \frac{1}{\sqrt N}(\Ket{10\dots00}+\Ket{01\dots00} + \dots +\Ket{00\dots01})$$

Требуется выполнить необходимые преобразования, чтобы точно различить эти два состояния. Возвращать $0$, если первое состояние и 1, если второе. 
\\\\
Код основной функции:
\begin{lstlisting}[language=Python]
def Solve_Second(q):
    str = q.measure()[0]   # measuring qubits 
    if (len(str) == 1):    # exception claimed
        if q == One:
            return 1
        else:
            return 0
    
    i = 0
    for qubit in str:
        if qubit == '1':
            i+=1
    if (i == 1):
        return 1
    else:
        return 0
    return i
\end{lstlisting}


\subsection{Различение состояний 2 (2 балла)}

Дано $2$ кубита, которые могут быть в одном из четырех состояний:

$$\Ket{S_0} = \frac{1}{2}(\Ket{00} + \Ket{01} + \Ket{10} + \Ket{11})$$
$$\Ket{S_1} = \frac{1}{2}(\Ket{00} - \Ket{01} + \Ket{10} - \Ket{11})$$
$$\Ket{S_2} = \frac{1}{2}(\Ket{00} + \Ket{01} - \Ket{10} - \Ket{11})$$
$$\Ket{S_3} = \frac{1}{2}(\Ket{00} - \Ket{01} - \Ket{10} + \Ket{11})$$


Требуется выполнить необходимые преобразования, чтобы точно различить эти четыре состояния. Возвращать требуется индекс состояния (от $0$ до $3$). 
\\\\
Код основной функции:
\begin{lstlisting}[language=Python]
def Solve_Third(q):
    global circuit
    circuit.initialize(q)         # putting our statevector into circut
    circuit.h(range(2))           # making Hadamar for both qubits
    
    state = Statevector(circuit)
    res = state.measure()[0]      # measuring qubits 
    if res[0] == '0':
        if res[1] == '0':
            return 0
        else:
            return 1
    else:
        if res[1] == '0':
            return 2
        else:
            return 3
\end{lstlisting}


\subsection{Написание оракула 1 (2 балла)}

Требуется реализовать квантовый оракул на $N$ кубитах ($1 \le N \le 8$), который реализует следующую функцию: $f(\pmb{x}) = (\pmb{b}\pmb{x}) \mod 2$, где  $\pmb{b} \in \{0,1\}^N$ вектор битов и  $\pmb{x}$ вектор кубитов. Выход функции записать в кубит $\pmb{y}$. Количество кубитов $N$ ($1 \le N \le 8$). 
\\\\
Заготовка для кода:
\begin{lstlisting}[language=Python]
\end{lstlisting}

\end{document}


